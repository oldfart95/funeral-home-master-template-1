---
import siteDetails from '@/config/siteDetails';
import { formatPhoneDisplay, formatPhoneTel } from '@/utils/phone';

interface Props {
  language?: 'en' | 'es';
}

const { language = 'en' } = Astro.props;

const content = {
  en: {
    heading: "Contact & Support",
    description: "Our compassionate team is here to guide you through every step.",
    available: "Available 24/7",
    formLabels: {
      name: "Your Name *",
      email: "Your Email Address *",
      phone: "Phone Number",
      message: "How can we help? *"
    },
    placeholders: {
      name: "Your name",
      email: "your@email.com",
      phone: "(111) 111-1111",
      message: "Tell us how we can help you plan ahead..."
    },
    submitButton: "Send Message",
    sending: "Sending...",
    validation: {
      nameRequired: "Please enter your full name",
      emailRequired: "Please enter your email address",
      emailInvalid: "Please enter a valid email address",
      messageRequired: "Please enter a message (at least 10 characters)",
      messageTooShort: "Please enter a message (at least 10 characters)"
    },
    errors: {
      validation: "An error occurred during validation. Please try again.",
      tooManyRequests: "Too many requests. Please try again later.",
      validationFailed: "Please check that all fields are complete and valid.",
      generic: "An error occurred. Please try again.",
      network: "An error occurred. Please try again or call us directly."
    },
    success: "Thank you for your message. We will get back to you soon."
  },
  es: {
    heading: "Contacto y Apoyo",
    description: "Nuestro equipo compasivo está aquí para guiarlo a través de cada paso.",
    available: "Disponible 24/7",
    formLabels: {
      name: "Su Nombre *",
      email: "Su Dirección de Correo Electrónico *",
      phone: "Número de Teléfono",
      message: "¿Cómo podemos ayudarle? *"
    },
    placeholders: {
      name: "Su nombre",
      email: "su@correo.com",
      phone: "(111) 111-1111",
      message: "Cuéntenos cómo podemos ayudarlo a planificar con anticipación..."
    },
    submitButton: "Enviar Mensaje",
    sending: "Enviando...",
    validation: {
      nameRequired: "Por favor ingrese su nombre completo",
      emailRequired: "Por favor ingrese su dirección de correo electrónico",
      emailInvalid: "Por favor ingrese una dirección de correo electrónico válida",
      messageRequired: "Por favor ingrese un mensaje (al menos 10 caracteres)",
      messageTooShort: "Por favor ingrese un mensaje (al menos 10 caracteres)"
    },
    errors: {
      validation: "Ocurrió un error durante la validación. Por favor, intente nuevamente.",
      tooManyRequests: "Demasiadas solicitudes. Por favor, intente nuevamente más tarde.",
      validationFailed: "Por favor, verifique que todos los campos estén completos y sean válidos.",
      generic: "Ocurrió un error. Por favor, intente nuevamente.",
      network: "Ocurrió un error. Por favor, intente nuevamente o llámenos directamente."
    },
    success: "Gracias por su mensaje. Nos pondremos en contacto con usted pronto."
  }
};

const text = content[language];
const phone = siteDetails.phone && siteDetails.phone !== '(111) 111-1111' 
  ? siteDetails.phone 
  : '(111) 111-1111';
---

<!-- Contact & Support Section -->
<section id="contact" class="py-10 md:py-24 bg-white">
  <div class="container mx-auto px-4 sm:px-6 lg:px-8">
    <div class="max-w-2xl mx-auto">
      <h2 class="text-2xl md:text-4xl font-heading font-bold text-primary mb-3 md:mb-4 text-center">
        {text.heading}
      </h2>
      <p class="text-base md:text-xl text-text text-center mb-6 md:mb-8">
        {text.description}
      </p>
      
      <!-- Phone Number Badge -->
      <div class="bg-primary text-white p-4 md:p-6 rounded-lg shadow-sm mb-6 md:mb-8 text-center">
        <p class="text-sm md:text-base text-white/90 mb-2">{text.available}</p>
        <a
          href={`tel:${formatPhoneTel(phone)}`}
          class="text-2xl md:text-3xl font-bold text-white hover:text-accent transition-all duration-200 inline-block hover:scale-105 active:scale-95 flex items-center justify-center gap-2 group"
        >
          <svg class="w-6 h-6 md:w-7 md:h-7 transition-transform duration-200 group-hover:rotate-12" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 5a2 2 0 012-2h3.28a1 1 0 01.948.684l1.498 4.493a1 1 0 01-.502 1.21l-2.257 1.13a11.042 11.042 0 005.516 5.516l1.13-2.257a1 1 0 011.21-.502l4.493 1.498a1 1 0 01.684.949V19a2 2 0 01-2 2h-1C9.716 21 3 14.284 3 6V5z"></path>
          </svg>
          <span>{formatPhoneDisplay(phone)}</span>
        </a>
      </div>
      
      <div class="bg-secondary p-5 md:p-12 rounded-lg shadow-sm">
        <form id="contact-form" class="space-y-4 md:space-y-6">
          <!-- Honeypot field for spam prevention -->
          <input type="text" name="honeypot" style="display: none;" tabindex="-1" autocomplete="off" />
          <!-- CSRF token field (hidden, populated by JavaScript) -->
          <input type="hidden" name="csrfToken" id="csrf-token" />
          
          <div>
            <label for="name" class="block text-sm font-semibold text-primary mb-2">
              {text.formLabels.name}
            </label>
            <input
              type="text"
              id="name"
              name="name"
              autocomplete="name"
              required
              class="w-full px-4 py-3 border border-gray-300 rounded-md focus:ring-2 focus:ring-accent focus:border-transparent"
              placeholder={text.placeholders.name}
            />
          </div>
          
          <div>
            <label for="email" class="block text-sm font-semibold text-primary mb-2">
              {text.formLabels.email}
            </label>
            <input
              type="email"
              id="email"
              name="email"
              autocomplete="email"
              required
              class="w-full px-4 py-3 border border-gray-300 rounded-md focus:ring-2 focus:ring-accent focus:border-transparent"
              placeholder={text.placeholders.email}
            />
          </div>
          
          <div>
            <label for="phone" class="block text-sm font-semibold text-primary mb-2">
              {text.formLabels.phone}
            </label>
            <input
              type="tel"
              id="phone"
              name="phone"
              autocomplete="tel"
              class="w-full px-4 py-3 border border-gray-300 rounded-md focus:ring-2 focus:ring-accent focus:border-transparent"
              placeholder={text.placeholders.phone}
            />
          </div>
          
          <div>
            <label for="message" class="block text-sm font-semibold text-primary mb-2">
              {text.formLabels.message}
            </label>
            <textarea
              id="message"
              name="message"
              autocomplete="off"
              required
              rows="5"
              class="w-full px-4 py-3 border border-gray-300 rounded-md focus:ring-2 focus:ring-accent focus:border-transparent"
              placeholder={text.placeholders.message}
            ></textarea>
          </div>
          
          <button
            type="submit"
            id="submit-button"
            class="w-full bg-accent text-white px-6 py-3 rounded-md font-semibold text-lg hover:bg-accent-dark transition-all duration-200 shadow-sm hover:shadow-md hover:scale-[1.02] active:scale-[0.98] flex items-center justify-center gap-2 disabled:opacity-70 disabled:cursor-not-allowed disabled:hover:scale-100 disabled:hover:shadow-sm relative group"
          >
            <span id="button-text" class="flex items-center gap-2">
              <span>{text.submitButton}</span>
              <svg class="w-5 h-5 transition-transform duration-200 group-hover:translate-x-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path>
              </svg>
            </span>
            <span id="button-spinner" class="hidden absolute inset-0 flex items-center justify-center">
              <svg class="animate-spin h-6 w-6 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" aria-hidden="true">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
              </svg>
            </span>
          </button>
          
          <div id="form-message" class="hidden mt-4 p-4 rounded-md"></div>
        </form>
      </div>
    </div>
  </div>
</section>

<script define:vars={{ language, text }}>
  (function() {
    try {
      // Type definitions
      interface FormData {
        name: string;
        email: string;
        phone: string;
        message: string;
        honeypot: string;
      }

      // Standardized API Response Types (matching API route)
      interface ApiSuccessResponse {
        success: true;
        message: string;
      }

      interface ApiErrorResponse {
        success: false;
        error: string;
        code?: string;
        details?: Array<{
          path?: string[];
          message?: string;
        }>;
      }

      type ApiResponse = ApiSuccessResponse | ApiErrorResponse;

      /**
       * Validates an email address using regex pattern
       * 
       * @param email - The email address to validate
       * @returns `true` if the email is valid, `false` otherwise
       */
      function isValidEmail(email: string): boolean {
        try {
          const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
          return emailRegex.test(email);
        } catch (err) {
          return false;
        }
      }

      /**
       * Validates form data client-side before submission
       * 
       * Checks all required fields and validates email format.
       * Returns an array of error messages (empty if validation passes).
       * 
       * @param formData - The form data to validate
       * @returns Array of error messages, empty if validation passes
       */
      function validateForm(formData: FormData): string[] {
        try {
          const errors: string[] = [];
          if (!formData.name || formData.name.trim().length < 2) {
            errors.push(text.validation.nameRequired);
          }
          if (!formData.email || formData.email.trim().length === 0) {
            errors.push(text.validation.emailRequired);
          } else if (!isValidEmail(formData.email)) {
            errors.push(text.validation.emailInvalid);
          }
          if (!formData.message || formData.message.trim().length < 10) {
            errors.push(text.validation.messageRequired);
          }
          return errors;
        } catch (err) {
          return [text.errors.validation];
        }
      }

      /**
       * Standardized error handler that matches API response format
       * 
       * Parses API error responses and converts them to user-friendly messages.
       * Handles validation errors, rate limiting, and other error codes.
       * Maps field-specific validation errors to localized messages.
       * 
       * @param data - The API error response object
       * @returns A user-friendly error message string
       */
      function handleApiError(data: ApiErrorResponse): string {
        try {
          // Handle validation errors with field-specific messages
          if (data.code === 'VALIDATION_ERROR' && data.details && Array.isArray(data.details) && data.details.length > 0) {
            const messages = data.details.map(error => {
              try {
                const field = error.path?.[0] || 'field';
                const message = error.message || '';
                
                // Map field-specific validation errors to user-friendly messages
                if (field === 'name') {
                  if (message.includes('at least 2')) {
                    return text.validation.nameRequired;
                  }
                } else if (field === 'email') {
                  if (message.includes('Invalid email') || message.includes('email')) {
                    return text.validation.emailInvalid;
                  }
                  if (message.includes('required')) {
                    return text.validation.emailRequired;
                  }
                } else if (field === 'message') {
                  if (message.includes('at least 10')) {
                    return text.validation.messageRequired;
                  }
                  if (message.includes('required')) {
                    return text.validation.messageRequired;
                  }
                }
                
                // Fallback to original message if no specific mapping
                return message;
              } catch (err) {
                return text.errors.validation;
              }
            });
            
            // Return first error or combined message
            return messages.length === 1 ? messages[0] : messages.join('. ');
          }
          
          // Handle specific error codes
          if (data.code) {
            switch (data.code) {
              case 'RATE_LIMIT_EXCEEDED':
                return text.errors.tooManyRequests;
              case 'CSRF_TOKEN_INVALID':
              case 'CSRF_TOKEN_ERROR':
                // Refresh CSRF token and show error
                fetchCsrfToken().then(token => {
                  csrfToken = token;
                  if (csrfTokenInput && token) {
                    csrfTokenInput.value = token;
                  }
                });
                return text.errors.validation; // Generic validation error for CSRF
              case 'VALIDATION_ERROR':
                return text.errors.validationFailed;
              case 'EMAIL_SEND_FAILED':
                return text.errors.network;
              case 'INVALID_REQUEST':
              case 'INVALID_JSON':
                return text.errors.validationFailed;
              case 'INTERNAL_SERVER_ERROR':
                return text.errors.network;
              default:
                // Fall through to error message
                break;
            }
          }
          
          // Use error message if available
          if (data.error) {
            return data.error;
          }
          
          // Fallback to generic error
          return text.errors.generic;
        } catch (err) {
          // Last resort fallback
          return text.errors.generic;
        }
      }

      /**
       * Standardized success handler
       * 
       * Extracts the success message from API response.
       * 
       * @param data - The API success response object
       * @returns The success message string
       */
      function handleApiSuccess(data: ApiSuccessResponse): string {
        return data.message || text.success;
      }

      /**
       * Standardized error display helper
       * 
       * Displays an error message in the form's message div with consistent styling.
       * 
       * @param message - The error message to display
       */
      function showError(message: string): void {
        if (messageDiv) {
          messageDiv.className = 'mt-4 p-4 rounded-md bg-red-100 text-red-800';
          messageDiv.textContent = message;
          messageDiv.classList.remove('hidden');
        }
      }

      /**
       * Standardized success display helper
       * 
       * Displays a success message in the form's message div with consistent styling.
       * 
       * @param message - The success message to display
       */
      function showSuccess(message: string): void {
        if (messageDiv) {
          messageDiv.className = 'mt-4 p-4 rounded-md bg-green-100 text-green-800';
          messageDiv.textContent = message;
          messageDiv.classList.remove('hidden');
        }
      }

      /**
       * Standardized loading state management
       * 
       * Manages the form's loading state by showing/hiding the spinner
       * and enabling/disabling the submit button.
       * 
       * @param isLoading - `true` to show loading state, `false` to hide it
       */
      function setLoadingState(isLoading: boolean): void {
        const submitButton = form?.querySelector('button[type="submit"]') as HTMLButtonElement;
        const buttonText = document.getElementById('button-text') as HTMLSpanElement;
        const buttonSpinner = document.getElementById('button-spinner') as HTMLSpanElement;
        
        if (submitButton && buttonText && buttonSpinner) {
          if (isLoading) {
            buttonText.textContent = text.sending;
            buttonText.classList.add('opacity-0');
            buttonSpinner.classList.remove('hidden');
            submitButton.disabled = true;
          } else {
            buttonText.textContent = text.submitButton;
            buttonText.classList.remove('opacity-0');
            buttonSpinner.classList.add('hidden');
            submitButton.disabled = false;
          }
        }
      }

      /**
       * Fetches a CSRF token from the API
       * 
       * @returns The CSRF token string, or null if fetch fails
       */
      async function fetchCsrfToken(): Promise<string | null> {
        try {
          const response = await fetch('/api/contact', {
            method: 'GET',
            headers: {
              'Content-Type': 'application/json',
            },
          });
          
          if (response.ok) {
            const data = await response.json();
            return data.csrfToken || null;
          }
          
          return null;
        } catch (error) {
          console.error('Failed to fetch CSRF token:', error);
          return null;
        }
      }

      // Contact form handling
      const form = document.getElementById('contact-form');
      const messageDiv = document.getElementById('form-message');
      const csrfTokenInput = document.getElementById('csrf-token') as HTMLInputElement;

      // Fetch CSRF token when form loads
      let csrfToken: string | null = null;
      if (form && csrfTokenInput) {
        fetchCsrfToken().then(token => {
          csrfToken = token;
          if (csrfTokenInput && token) {
            csrfTokenInput.value = token;
          }
        });
      }

      if (form && messageDiv) {
        form.addEventListener('submit', async (e) => {
          try {
            e.preventDefault();
            
            // Ensure we have a CSRF token before submitting
            if (!csrfToken && csrfTokenInput) {
              csrfToken = csrfTokenInput.value || await fetchCsrfToken();
              if (csrfToken && csrfTokenInput) {
                csrfTokenInput.value = csrfToken;
              }
            }
            
            if (!csrfToken) {
              showError(text.errors.network);
              return;
            }

            const formData: FormData = {
              name: (document.getElementById('name') as HTMLInputElement)?.value || '',
              email: (document.getElementById('email') as HTMLInputElement)?.value || '',
              phone: (document.getElementById('phone') as HTMLInputElement)?.value || '',
              message: (document.getElementById('message') as HTMLTextAreaElement)?.value || '',
              honeypot: (document.querySelector('input[name="honeypot"]') as HTMLInputElement)?.value || '',
              csrfToken: csrfToken,
            };

            // Client-side validation
            const validationErrors = validateForm(formData);
            if (validationErrors.length > 0) {
              showError(validationErrors[0]);
              return;
            }

            // Show loading state
            setLoadingState(true);
            messageDiv.classList.add('hidden');

            try {
              const response = await fetch('/api/contact', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify(formData),
              });

              // Parse response with proper error handling
              let data: ApiResponse;
              try {
                data = await response.json() as ApiResponse;
              } catch (parseError) {
                // Handle JSON parse errors
                showError(text.errors.network);
                setLoadingState(false);
                return;
              }

              // Handle response based on standardized format
              if (response.ok && 'success' in data && data.success === true) {
                showSuccess(handleApiSuccess(data));
                form.reset();
                // Fetch new CSRF token after successful submission
                fetchCsrfToken().then(token => {
                  csrfToken = token;
                  if (csrfTokenInput && token) {
                    csrfTokenInput.value = token;
                  }
                });
              } else if ('success' in data && data.success === false) {
                showError(handleApiError(data));
              } else {
                // Fallback for unexpected response format
                showError(text.errors.generic);
              }
            } catch (error) {
              // Handle network errors, fetch failures, etc.
              console.error('Contact form submission error:', error);
              showError(text.errors.network);
            } finally {
              setLoadingState(false);
            }
          } catch (error) {
            // Handle unexpected errors in form submission
            console.error('Unexpected form error:', error);
            showError(text.errors.network);
            setLoadingState(false);
          }
        });
      }
    } catch (error) {
      // Silently fail - form will still work via native HTML submission if JS fails
    }
  })();
</script>

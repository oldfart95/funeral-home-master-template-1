import { e as createAstro, f as createComponent, m as maybeRenderHead, r as renderTemplate, n as defineScriptVars, h as addAttribute } from './astro/server.CJ8kye3e.js';
import 'piccolore';
import 'clsx';
import siteDetails from './siteDetails.B9KLVKNZ.js';
import { a as formatPhoneDisplay, f as formatPhoneTel } from './Layout.CGO4HiXi.js';

const $$Astro$1 = createAstro("https://example.com");
const $$OngoingCare = createComponent(($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro$1, $$props, $$slots);
  Astro2.self = $$OngoingCare;
  const { language = "en" } = Astro2.props;
  const content = {
    en: {
      text: "Our care does not end when the service concludes. We are here to assist with the practicalities of loss\u2014from grief resources to assistance with documentation\u2014ensuring you never have to navigate the path forward alone."
    },
    es: {
      text: "Nuestro cuidado no termina cuando concluye el servicio. Estamos aqu\xED para ayudar con las practicidades de la p\xE9rdida\u2014desde recursos de duelo hasta asistencia con documentaci\xF3n\u2014asegurando que nunca tenga que navegar el camino hacia adelante solo."
    }
  };
  const text = content[language];
  return renderTemplate`<!-- Ongoing Care Section -->${maybeRenderHead()}<section class="py-10 md:py-16 bg-white"> <div class="container mx-auto px-4 sm:px-6 lg:px-8"> <div class="max-w-4xl mx-auto"> <p class="text-base md:text-lg lg:text-xl text-text leading-relaxed text-center"> ${text.text} </p> </div> </div> </section>`;
}, "C:/Users/User A/Documents/GitHub/funeral-home-landing-site/src/components/OngoingCare.astro", void 0);

var __freeze = Object.freeze;
var __defProp = Object.defineProperty;
var __template = (cooked, raw) => __freeze(__defProp(cooked, "raw", { value: __freeze(raw || cooked.slice()) }));
var _a;
const $$Astro = createAstro("https://example.com");
const $$ContactForm = createComponent(async ($$result, $$props, $$slots) => {
  const Astro2 = $$result.createAstro($$Astro, $$props, $$slots);
  Astro2.self = $$ContactForm;
  const { language = "en" } = Astro2.props;
  const content = {
    en: {
      heading: "Contact & Support",
      description: "Our compassionate team is here to guide you through every step.",
      available: "Available 24/7",
      formLabels: {
        name: "Your Name *",
        email: "Your Email Address *",
        phone: "Phone Number",
        message: "How can we help? *"
      },
      placeholders: {
        name: "Your name",
        email: "your@email.com",
        phone: "(111) 111-1111",
        message: "Tell us how we can help you plan ahead..."
      },
      submitButton: "Send Message",
      sending: "Sending...",
      validation: {
        nameRequired: "Please enter your full name",
        emailRequired: "Please enter your email address",
        emailInvalid: "Please enter a valid email address",
        messageRequired: "Please enter a message (at least 10 characters)",
        messageTooShort: "Please enter a message (at least 10 characters)"
      },
      errors: {
        validation: "An error occurred during validation. Please try again.",
        tooManyRequests: "Too many requests. Please try again later.",
        validationFailed: "Please check that all fields are complete and valid.",
        generic: "An error occurred. Please try again.",
        network: "An error occurred. Please try again or call us directly."
      },
      success: "Thank you for your message. We will get back to you soon."
    },
    es: {
      heading: "Contacto y Apoyo",
      description: "Nuestro equipo compasivo est\xE1 aqu\xED para guiarlo a trav\xE9s de cada paso.",
      available: "Disponible 24/7",
      formLabels: {
        name: "Su Nombre *",
        email: "Su Direcci\xF3n de Correo Electr\xF3nico *",
        phone: "N\xFAmero de Tel\xE9fono",
        message: "\xBFC\xF3mo podemos ayudarle? *"
      },
      placeholders: {
        name: "Su nombre",
        email: "su@correo.com",
        phone: "(111) 111-1111",
        message: "Cu\xE9ntenos c\xF3mo podemos ayudarlo a planificar con anticipaci\xF3n..."
      },
      submitButton: "Enviar Mensaje",
      sending: "Enviando...",
      validation: {
        nameRequired: "Por favor ingrese su nombre completo",
        emailRequired: "Por favor ingrese su direcci\xF3n de correo electr\xF3nico",
        emailInvalid: "Por favor ingrese una direcci\xF3n de correo electr\xF3nico v\xE1lida",
        messageRequired: "Por favor ingrese un mensaje (al menos 10 caracteres)",
        messageTooShort: "Por favor ingrese un mensaje (al menos 10 caracteres)"
      },
      errors: {
        validation: "Ocurri\xF3 un error durante la validaci\xF3n. Por favor, intente nuevamente.",
        tooManyRequests: "Demasiadas solicitudes. Por favor, intente nuevamente m\xE1s tarde.",
        validationFailed: "Por favor, verifique que todos los campos est\xE9n completos y sean v\xE1lidos.",
        generic: "Ocurri\xF3 un error. Por favor, intente nuevamente.",
        network: "Ocurri\xF3 un error. Por favor, intente nuevamente o ll\xE1menos directamente."
      },
      success: "Gracias por su mensaje. Nos pondremos en contacto con usted pronto."
    }
  };
  const text = content[language];
  const phone = siteDetails.phone && siteDetails.phone !== "(111) 111-1111" ? siteDetails.phone : "(111) 111-1111";
  return renderTemplate(_a || (_a = __template(["<!-- Contact & Support Section -->", '<section id="contact" class="py-10 md:py-24 bg-white"> <div class="container mx-auto px-4 sm:px-6 lg:px-8"> <div class="max-w-2xl mx-auto"> <h2 class="text-2xl md:text-4xl font-heading font-bold text-primary mb-3 md:mb-4 text-center"> ', ' </h2> <p class="text-base md:text-xl text-text text-center mb-6 md:mb-8"> ', ' </p> <!-- Phone Number Badge --> <div class="bg-primary text-white p-4 md:p-6 rounded-lg shadow-sm mb-6 md:mb-8 text-center"> <p class="text-sm md:text-base text-white/90 mb-2">', "</p> <a", ' class="text-2xl md:text-3xl font-bold text-white hover:text-accent transition-all duration-200 inline-block hover:scale-105 active:scale-95 flex items-center justify-center gap-2 group"> <svg class="w-6 h-6 md:w-7 md:h-7 transition-transform duration-200 group-hover:rotate-12" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 5a2 2 0 012-2h3.28a1 1 0 01.948.684l1.498 4.493a1 1 0 01-.502 1.21l-2.257 1.13a11.042 11.042 0 005.516 5.516l1.13-2.257a1 1 0 011.21-.502l4.493 1.498a1 1 0 01.684.949V19a2 2 0 01-2 2h-1C9.716 21 3 14.284 3 6V5z"></path> </svg> <span>', '</span> </a> </div> <div class="bg-secondary p-5 md:p-12 rounded-lg shadow-sm"> <form id="contact-form" class="space-y-4 md:space-y-6"> <!-- Honeypot field for spam prevention --> <input type="text" name="honeypot" style="display: none;" tabindex="-1" autocomplete="off"> <!-- CSRF token field (hidden, populated by JavaScript) --> <input type="hidden" name="csrfToken" id="csrf-token"> <div> <label for="name" class="block text-sm font-semibold text-primary mb-2"> ', ' </label> <input type="text" id="name" name="name" autocomplete="name" required class="w-full px-4 py-3 border border-gray-300 rounded-md focus:ring-2 focus:ring-accent focus:border-transparent"', '> </div> <div> <label for="email" class="block text-sm font-semibold text-primary mb-2"> ', ' </label> <input type="email" id="email" name="email" autocomplete="email" required class="w-full px-4 py-3 border border-gray-300 rounded-md focus:ring-2 focus:ring-accent focus:border-transparent"', '> </div> <div> <label for="phone" class="block text-sm font-semibold text-primary mb-2"> ', ' </label> <input type="tel" id="phone" name="phone" autocomplete="tel" class="w-full px-4 py-3 border border-gray-300 rounded-md focus:ring-2 focus:ring-accent focus:border-transparent"', '> </div> <div> <label for="message" class="block text-sm font-semibold text-primary mb-2"> ', ' </label> <textarea id="message" name="message" autocomplete="off" required rows="5" class="w-full px-4 py-3 border border-gray-300 rounded-md focus:ring-2 focus:ring-accent focus:border-transparent"', '></textarea> </div> <button type="submit" id="submit-button" class="w-full bg-accent text-white px-6 py-3 rounded-md font-semibold text-lg hover:bg-accent-dark transition-all duration-200 shadow-sm hover:shadow-md hover:scale-[1.02] active:scale-[0.98] flex items-center justify-center gap-2 disabled:opacity-70 disabled:cursor-not-allowed disabled:hover:scale-100 disabled:hover:shadow-sm relative group"> <span id="button-text" class="flex items-center gap-2"> <span>', '</span> <svg class="w-5 h-5 transition-transform duration-200 group-hover:translate-x-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path> </svg> </span> <span id="button-spinner" class="hidden absolute inset-0 flex items-center justify-center"> <svg class="animate-spin h-6 w-6 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" aria-hidden="true"> <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle> <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path> </svg> </span> </button> <div id="form-message" class="hidden mt-4 p-4 rounded-md"></div> </form> </div> </div> </div> </section> <script>(function(){', "\n  (function() {\n    try {\n      // Type definitions\n      interface FormData {\n        name: string;\n        email: string;\n        phone: string;\n        message: string;\n        honeypot: string;\n      }\n\n      // Standardized API Response Types (matching API route)\n      interface ApiSuccessResponse {\n        success: true;\n        message: string;\n      }\n\n      interface ApiErrorResponse {\n        success: false;\n        error: string;\n        code?: string;\n        details?: Array<{\n          path?: string[];\n          message?: string;\n        }>;\n      }\n\n      type ApiResponse = ApiSuccessResponse | ApiErrorResponse;\n\n      /**\n       * Validates an email address using regex pattern\n       * \n       * @param email - The email address to validate\n       * @returns `true` if the email is valid, `false` otherwise\n       */\n      function isValidEmail(email: string): boolean {\n        try {\n          const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n          return emailRegex.test(email);\n        } catch (err) {\n          return false;\n        }\n      }\n\n      /**\n       * Validates form data client-side before submission\n       * \n       * Checks all required fields and validates email format.\n       * Returns an array of error messages (empty if validation passes).\n       * \n       * @param formData - The form data to validate\n       * @returns Array of error messages, empty if validation passes\n       */\n      function validateForm(formData: FormData): string[] {\n        try {\n          const errors: string[] = [];\n          if (!formData.name || formData.name.trim().length < 2) {\n            errors.push(text.validation.nameRequired);\n          }\n          if (!formData.email || formData.email.trim().length === 0) {\n            errors.push(text.validation.emailRequired);\n          } else if (!isValidEmail(formData.email)) {\n            errors.push(text.validation.emailInvalid);\n          }\n          if (!formData.message || formData.message.trim().length < 10) {\n            errors.push(text.validation.messageRequired);\n          }\n          return errors;\n        } catch (err) {\n          return [text.errors.validation];\n        }\n      }\n\n      /**\n       * Standardized error handler that matches API response format\n       * \n       * Parses API error responses and converts them to user-friendly messages.\n       * Handles validation errors, rate limiting, and other error codes.\n       * Maps field-specific validation errors to localized messages.\n       * \n       * @param data - The API error response object\n       * @returns A user-friendly error message string\n       */\n      function handleApiError(data: ApiErrorResponse): string {\n        try {\n          // Handle validation errors with field-specific messages\n          if (data.code === 'VALIDATION_ERROR' && data.details && Array.isArray(data.details) && data.details.length > 0) {\n            const messages = data.details.map(error => {\n              try {\n                const field = error.path?.[0] || 'field';\n                const message = error.message || '';\n                \n                // Map field-specific validation errors to user-friendly messages\n                if (field === 'name') {\n                  if (message.includes('at least 2')) {\n                    return text.validation.nameRequired;\n                  }\n                } else if (field === 'email') {\n                  if (message.includes('Invalid email') || message.includes('email')) {\n                    return text.validation.emailInvalid;\n                  }\n                  if (message.includes('required')) {\n                    return text.validation.emailRequired;\n                  }\n                } else if (field === 'message') {\n                  if (message.includes('at least 10')) {\n                    return text.validation.messageRequired;\n                  }\n                  if (message.includes('required')) {\n                    return text.validation.messageRequired;\n                  }\n                }\n                \n                // Fallback to original message if no specific mapping\n                return message;\n              } catch (err) {\n                return text.errors.validation;\n              }\n            });\n            \n            // Return first error or combined message\n            return messages.length === 1 ? messages[0] : messages.join('. ');\n          }\n          \n          // Handle specific error codes\n          if (data.code) {\n            switch (data.code) {\n              case 'RATE_LIMIT_EXCEEDED':\n                return text.errors.tooManyRequests;\n              case 'CSRF_TOKEN_INVALID':\n              case 'CSRF_TOKEN_ERROR':\n                // Refresh CSRF token and show error\n                fetchCsrfToken().then(token => {\n                  csrfToken = token;\n                  if (csrfTokenInput && token) {\n                    csrfTokenInput.value = token;\n                  }\n                });\n                return text.errors.validation; // Generic validation error for CSRF\n              case 'VALIDATION_ERROR':\n                return text.errors.validationFailed;\n              case 'EMAIL_SEND_FAILED':\n                return text.errors.network;\n              case 'INVALID_REQUEST':\n              case 'INVALID_JSON':\n                return text.errors.validationFailed;\n              case 'INTERNAL_SERVER_ERROR':\n                return text.errors.network;\n              default:\n                // Fall through to error message\n                break;\n            }\n          }\n          \n          // Use error message if available\n          if (data.error) {\n            return data.error;\n          }\n          \n          // Fallback to generic error\n          return text.errors.generic;\n        } catch (err) {\n          // Last resort fallback\n          return text.errors.generic;\n        }\n      }\n\n      /**\n       * Standardized success handler\n       * \n       * Extracts the success message from API response.\n       * \n       * @param data - The API success response object\n       * @returns The success message string\n       */\n      function handleApiSuccess(data: ApiSuccessResponse): string {\n        return data.message || text.success;\n      }\n\n      /**\n       * Standardized error display helper\n       * \n       * Displays an error message in the form's message div with consistent styling.\n       * \n       * @param message - The error message to display\n       */\n      function showError(message: string): void {\n        if (messageDiv) {\n          messageDiv.className = 'mt-4 p-4 rounded-md bg-red-100 text-red-800';\n          messageDiv.textContent = message;\n          messageDiv.classList.remove('hidden');\n        }\n      }\n\n      /**\n       * Standardized success display helper\n       * \n       * Displays a success message in the form's message div with consistent styling.\n       * \n       * @param message - The success message to display\n       */\n      function showSuccess(message: string): void {\n        if (messageDiv) {\n          messageDiv.className = 'mt-4 p-4 rounded-md bg-green-100 text-green-800';\n          messageDiv.textContent = message;\n          messageDiv.classList.remove('hidden');\n        }\n      }\n\n      /**\n       * Standardized loading state management\n       * \n       * Manages the form's loading state by showing/hiding the spinner\n       * and enabling/disabling the submit button.\n       * \n       * @param isLoading - `true` to show loading state, `false` to hide it\n       */\n      function setLoadingState(isLoading: boolean): void {\n        const submitButton = form?.querySelector('button[type=\"submit\"]') as HTMLButtonElement;\n        const buttonText = document.getElementById('button-text') as HTMLSpanElement;\n        const buttonSpinner = document.getElementById('button-spinner') as HTMLSpanElement;\n        \n        if (submitButton && buttonText && buttonSpinner) {\n          if (isLoading) {\n            buttonText.textContent = text.sending;\n            buttonText.classList.add('opacity-0');\n            buttonSpinner.classList.remove('hidden');\n            submitButton.disabled = true;\n          } else {\n            buttonText.textContent = text.submitButton;\n            buttonText.classList.remove('opacity-0');\n            buttonSpinner.classList.add('hidden');\n            submitButton.disabled = false;\n          }\n        }\n      }\n\n      /**\n       * Fetches a CSRF token from the API\n       * \n       * @returns The CSRF token string, or null if fetch fails\n       */\n      async function fetchCsrfToken(): Promise<string | null> {\n        try {\n          const response = await fetch('/api/contact', {\n            method: 'GET',\n            headers: {\n              'Content-Type': 'application/json',\n            },\n          });\n          \n          if (response.ok) {\n            const data = await response.json();\n            return data.csrfToken || null;\n          }\n          \n          return null;\n        } catch (error) {\n          console.error('Failed to fetch CSRF token:', error);\n          return null;\n        }\n      }\n\n      // Contact form handling\n      const form = document.getElementById('contact-form');\n      const messageDiv = document.getElementById('form-message');\n      const csrfTokenInput = document.getElementById('csrf-token') as HTMLInputElement;\n\n      // Fetch CSRF token when form loads\n      let csrfToken: string | null = null;\n      if (form && csrfTokenInput) {\n        fetchCsrfToken().then(token => {\n          csrfToken = token;\n          if (csrfTokenInput && token) {\n            csrfTokenInput.value = token;\n          }\n        });\n      }\n\n      if (form && messageDiv) {\n        form.addEventListener('submit', async (e) => {\n          try {\n            e.preventDefault();\n            \n            // Ensure we have a CSRF token before submitting\n            if (!csrfToken && csrfTokenInput) {\n              csrfToken = csrfTokenInput.value || await fetchCsrfToken();\n              if (csrfToken && csrfTokenInput) {\n                csrfTokenInput.value = csrfToken;\n              }\n            }\n            \n            if (!csrfToken) {\n              showError(text.errors.network);\n              return;\n            }\n\n            const formData: FormData = {\n              name: (document.getElementById('name') as HTMLInputElement)?.value || '',\n              email: (document.getElementById('email') as HTMLInputElement)?.value || '',\n              phone: (document.getElementById('phone') as HTMLInputElement)?.value || '',\n              message: (document.getElementById('message') as HTMLTextAreaElement)?.value || '',\n              honeypot: (document.querySelector('input[name=\"honeypot\"]') as HTMLInputElement)?.value || '',\n              csrfToken: csrfToken,\n            };\n\n            // Client-side validation\n            const validationErrors = validateForm(formData);\n            if (validationErrors.length > 0) {\n              showError(validationErrors[0]);\n              return;\n            }\n\n            // Show loading state\n            setLoadingState(true);\n            messageDiv.classList.add('hidden');\n\n            try {\n              const response = await fetch('/api/contact', {\n                method: 'POST',\n                headers: {\n                  'Content-Type': 'application/json',\n                },\n                body: JSON.stringify(formData),\n              });\n\n              // Parse response with proper error handling\n              let data: ApiResponse;\n              try {\n                data = await response.json() as ApiResponse;\n              } catch (parseError) {\n                // Handle JSON parse errors\n                showError(text.errors.network);\n                setLoadingState(false);\n                return;\n              }\n\n              // Handle response based on standardized format\n              if (response.ok && 'success' in data && data.success === true) {\n                showSuccess(handleApiSuccess(data));\n                form.reset();\n                // Fetch new CSRF token after successful submission\n                fetchCsrfToken().then(token => {\n                  csrfToken = token;\n                  if (csrfTokenInput && token) {\n                    csrfTokenInput.value = token;\n                  }\n                });\n              } else if ('success' in data && data.success === false) {\n                showError(handleApiError(data));\n              } else {\n                // Fallback for unexpected response format\n                showError(text.errors.generic);\n              }\n            } catch (error) {\n              // Handle network errors, fetch failures, etc.\n              console.error('Contact form submission error:', error);\n              showError(text.errors.network);\n            } finally {\n              setLoadingState(false);\n            }\n          } catch (error) {\n            // Handle unexpected errors in form submission\n            console.error('Unexpected form error:', error);\n            showError(text.errors.network);\n            setLoadingState(false);\n          }\n        });\n      }\n    } catch (error) {\n      // Silently fail - form will still work via native HTML submission if JS fails\n    }\n  })();\n})();<\/script>"], ["<!-- Contact & Support Section -->", '<section id="contact" class="py-10 md:py-24 bg-white"> <div class="container mx-auto px-4 sm:px-6 lg:px-8"> <div class="max-w-2xl mx-auto"> <h2 class="text-2xl md:text-4xl font-heading font-bold text-primary mb-3 md:mb-4 text-center"> ', ' </h2> <p class="text-base md:text-xl text-text text-center mb-6 md:mb-8"> ', ' </p> <!-- Phone Number Badge --> <div class="bg-primary text-white p-4 md:p-6 rounded-lg shadow-sm mb-6 md:mb-8 text-center"> <p class="text-sm md:text-base text-white/90 mb-2">', "</p> <a", ' class="text-2xl md:text-3xl font-bold text-white hover:text-accent transition-all duration-200 inline-block hover:scale-105 active:scale-95 flex items-center justify-center gap-2 group"> <svg class="w-6 h-6 md:w-7 md:h-7 transition-transform duration-200 group-hover:rotate-12" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 5a2 2 0 012-2h3.28a1 1 0 01.948.684l1.498 4.493a1 1 0 01-.502 1.21l-2.257 1.13a11.042 11.042 0 005.516 5.516l1.13-2.257a1 1 0 011.21-.502l4.493 1.498a1 1 0 01.684.949V19a2 2 0 01-2 2h-1C9.716 21 3 14.284 3 6V5z"></path> </svg> <span>', '</span> </a> </div> <div class="bg-secondary p-5 md:p-12 rounded-lg shadow-sm"> <form id="contact-form" class="space-y-4 md:space-y-6"> <!-- Honeypot field for spam prevention --> <input type="text" name="honeypot" style="display: none;" tabindex="-1" autocomplete="off"> <!-- CSRF token field (hidden, populated by JavaScript) --> <input type="hidden" name="csrfToken" id="csrf-token"> <div> <label for="name" class="block text-sm font-semibold text-primary mb-2"> ', ' </label> <input type="text" id="name" name="name" autocomplete="name" required class="w-full px-4 py-3 border border-gray-300 rounded-md focus:ring-2 focus:ring-accent focus:border-transparent"', '> </div> <div> <label for="email" class="block text-sm font-semibold text-primary mb-2"> ', ' </label> <input type="email" id="email" name="email" autocomplete="email" required class="w-full px-4 py-3 border border-gray-300 rounded-md focus:ring-2 focus:ring-accent focus:border-transparent"', '> </div> <div> <label for="phone" class="block text-sm font-semibold text-primary mb-2"> ', ' </label> <input type="tel" id="phone" name="phone" autocomplete="tel" class="w-full px-4 py-3 border border-gray-300 rounded-md focus:ring-2 focus:ring-accent focus:border-transparent"', '> </div> <div> <label for="message" class="block text-sm font-semibold text-primary mb-2"> ', ' </label> <textarea id="message" name="message" autocomplete="off" required rows="5" class="w-full px-4 py-3 border border-gray-300 rounded-md focus:ring-2 focus:ring-accent focus:border-transparent"', '></textarea> </div> <button type="submit" id="submit-button" class="w-full bg-accent text-white px-6 py-3 rounded-md font-semibold text-lg hover:bg-accent-dark transition-all duration-200 shadow-sm hover:shadow-md hover:scale-[1.02] active:scale-[0.98] flex items-center justify-center gap-2 disabled:opacity-70 disabled:cursor-not-allowed disabled:hover:scale-100 disabled:hover:shadow-sm relative group"> <span id="button-text" class="flex items-center gap-2"> <span>', '</span> <svg class="w-5 h-5 transition-transform duration-200 group-hover:translate-x-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"> <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path> </svg> </span> <span id="button-spinner" class="hidden absolute inset-0 flex items-center justify-center"> <svg class="animate-spin h-6 w-6 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" aria-hidden="true"> <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle> <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path> </svg> </span> </button> <div id="form-message" class="hidden mt-4 p-4 rounded-md"></div> </form> </div> </div> </div> </section> <script>(function(){', "\n  (function() {\n    try {\n      // Type definitions\n      interface FormData {\n        name: string;\n        email: string;\n        phone: string;\n        message: string;\n        honeypot: string;\n      }\n\n      // Standardized API Response Types (matching API route)\n      interface ApiSuccessResponse {\n        success: true;\n        message: string;\n      }\n\n      interface ApiErrorResponse {\n        success: false;\n        error: string;\n        code?: string;\n        details?: Array<{\n          path?: string[];\n          message?: string;\n        }>;\n      }\n\n      type ApiResponse = ApiSuccessResponse | ApiErrorResponse;\n\n      /**\n       * Validates an email address using regex pattern\n       * \n       * @param email - The email address to validate\n       * @returns \\`true\\` if the email is valid, \\`false\\` otherwise\n       */\n      function isValidEmail(email: string): boolean {\n        try {\n          const emailRegex = /^[^\\\\s@]+@[^\\\\s@]+\\\\.[^\\\\s@]+$/;\n          return emailRegex.test(email);\n        } catch (err) {\n          return false;\n        }\n      }\n\n      /**\n       * Validates form data client-side before submission\n       * \n       * Checks all required fields and validates email format.\n       * Returns an array of error messages (empty if validation passes).\n       * \n       * @param formData - The form data to validate\n       * @returns Array of error messages, empty if validation passes\n       */\n      function validateForm(formData: FormData): string[] {\n        try {\n          const errors: string[] = [];\n          if (!formData.name || formData.name.trim().length < 2) {\n            errors.push(text.validation.nameRequired);\n          }\n          if (!formData.email || formData.email.trim().length === 0) {\n            errors.push(text.validation.emailRequired);\n          } else if (!isValidEmail(formData.email)) {\n            errors.push(text.validation.emailInvalid);\n          }\n          if (!formData.message || formData.message.trim().length < 10) {\n            errors.push(text.validation.messageRequired);\n          }\n          return errors;\n        } catch (err) {\n          return [text.errors.validation];\n        }\n      }\n\n      /**\n       * Standardized error handler that matches API response format\n       * \n       * Parses API error responses and converts them to user-friendly messages.\n       * Handles validation errors, rate limiting, and other error codes.\n       * Maps field-specific validation errors to localized messages.\n       * \n       * @param data - The API error response object\n       * @returns A user-friendly error message string\n       */\n      function handleApiError(data: ApiErrorResponse): string {\n        try {\n          // Handle validation errors with field-specific messages\n          if (data.code === 'VALIDATION_ERROR' && data.details && Array.isArray(data.details) && data.details.length > 0) {\n            const messages = data.details.map(error => {\n              try {\n                const field = error.path?.[0] || 'field';\n                const message = error.message || '';\n                \n                // Map field-specific validation errors to user-friendly messages\n                if (field === 'name') {\n                  if (message.includes('at least 2')) {\n                    return text.validation.nameRequired;\n                  }\n                } else if (field === 'email') {\n                  if (message.includes('Invalid email') || message.includes('email')) {\n                    return text.validation.emailInvalid;\n                  }\n                  if (message.includes('required')) {\n                    return text.validation.emailRequired;\n                  }\n                } else if (field === 'message') {\n                  if (message.includes('at least 10')) {\n                    return text.validation.messageRequired;\n                  }\n                  if (message.includes('required')) {\n                    return text.validation.messageRequired;\n                  }\n                }\n                \n                // Fallback to original message if no specific mapping\n                return message;\n              } catch (err) {\n                return text.errors.validation;\n              }\n            });\n            \n            // Return first error or combined message\n            return messages.length === 1 ? messages[0] : messages.join('. ');\n          }\n          \n          // Handle specific error codes\n          if (data.code) {\n            switch (data.code) {\n              case 'RATE_LIMIT_EXCEEDED':\n                return text.errors.tooManyRequests;\n              case 'CSRF_TOKEN_INVALID':\n              case 'CSRF_TOKEN_ERROR':\n                // Refresh CSRF token and show error\n                fetchCsrfToken().then(token => {\n                  csrfToken = token;\n                  if (csrfTokenInput && token) {\n                    csrfTokenInput.value = token;\n                  }\n                });\n                return text.errors.validation; // Generic validation error for CSRF\n              case 'VALIDATION_ERROR':\n                return text.errors.validationFailed;\n              case 'EMAIL_SEND_FAILED':\n                return text.errors.network;\n              case 'INVALID_REQUEST':\n              case 'INVALID_JSON':\n                return text.errors.validationFailed;\n              case 'INTERNAL_SERVER_ERROR':\n                return text.errors.network;\n              default:\n                // Fall through to error message\n                break;\n            }\n          }\n          \n          // Use error message if available\n          if (data.error) {\n            return data.error;\n          }\n          \n          // Fallback to generic error\n          return text.errors.generic;\n        } catch (err) {\n          // Last resort fallback\n          return text.errors.generic;\n        }\n      }\n\n      /**\n       * Standardized success handler\n       * \n       * Extracts the success message from API response.\n       * \n       * @param data - The API success response object\n       * @returns The success message string\n       */\n      function handleApiSuccess(data: ApiSuccessResponse): string {\n        return data.message || text.success;\n      }\n\n      /**\n       * Standardized error display helper\n       * \n       * Displays an error message in the form's message div with consistent styling.\n       * \n       * @param message - The error message to display\n       */\n      function showError(message: string): void {\n        if (messageDiv) {\n          messageDiv.className = 'mt-4 p-4 rounded-md bg-red-100 text-red-800';\n          messageDiv.textContent = message;\n          messageDiv.classList.remove('hidden');\n        }\n      }\n\n      /**\n       * Standardized success display helper\n       * \n       * Displays a success message in the form's message div with consistent styling.\n       * \n       * @param message - The success message to display\n       */\n      function showSuccess(message: string): void {\n        if (messageDiv) {\n          messageDiv.className = 'mt-4 p-4 rounded-md bg-green-100 text-green-800';\n          messageDiv.textContent = message;\n          messageDiv.classList.remove('hidden');\n        }\n      }\n\n      /**\n       * Standardized loading state management\n       * \n       * Manages the form's loading state by showing/hiding the spinner\n       * and enabling/disabling the submit button.\n       * \n       * @param isLoading - \\`true\\` to show loading state, \\`false\\` to hide it\n       */\n      function setLoadingState(isLoading: boolean): void {\n        const submitButton = form?.querySelector('button[type=\"submit\"]') as HTMLButtonElement;\n        const buttonText = document.getElementById('button-text') as HTMLSpanElement;\n        const buttonSpinner = document.getElementById('button-spinner') as HTMLSpanElement;\n        \n        if (submitButton && buttonText && buttonSpinner) {\n          if (isLoading) {\n            buttonText.textContent = text.sending;\n            buttonText.classList.add('opacity-0');\n            buttonSpinner.classList.remove('hidden');\n            submitButton.disabled = true;\n          } else {\n            buttonText.textContent = text.submitButton;\n            buttonText.classList.remove('opacity-0');\n            buttonSpinner.classList.add('hidden');\n            submitButton.disabled = false;\n          }\n        }\n      }\n\n      /**\n       * Fetches a CSRF token from the API\n       * \n       * @returns The CSRF token string, or null if fetch fails\n       */\n      async function fetchCsrfToken(): Promise<string | null> {\n        try {\n          const response = await fetch('/api/contact', {\n            method: 'GET',\n            headers: {\n              'Content-Type': 'application/json',\n            },\n          });\n          \n          if (response.ok) {\n            const data = await response.json();\n            return data.csrfToken || null;\n          }\n          \n          return null;\n        } catch (error) {\n          console.error('Failed to fetch CSRF token:', error);\n          return null;\n        }\n      }\n\n      // Contact form handling\n      const form = document.getElementById('contact-form');\n      const messageDiv = document.getElementById('form-message');\n      const csrfTokenInput = document.getElementById('csrf-token') as HTMLInputElement;\n\n      // Fetch CSRF token when form loads\n      let csrfToken: string | null = null;\n      if (form && csrfTokenInput) {\n        fetchCsrfToken().then(token => {\n          csrfToken = token;\n          if (csrfTokenInput && token) {\n            csrfTokenInput.value = token;\n          }\n        });\n      }\n\n      if (form && messageDiv) {\n        form.addEventListener('submit', async (e) => {\n          try {\n            e.preventDefault();\n            \n            // Ensure we have a CSRF token before submitting\n            if (!csrfToken && csrfTokenInput) {\n              csrfToken = csrfTokenInput.value || await fetchCsrfToken();\n              if (csrfToken && csrfTokenInput) {\n                csrfTokenInput.value = csrfToken;\n              }\n            }\n            \n            if (!csrfToken) {\n              showError(text.errors.network);\n              return;\n            }\n\n            const formData: FormData = {\n              name: (document.getElementById('name') as HTMLInputElement)?.value || '',\n              email: (document.getElementById('email') as HTMLInputElement)?.value || '',\n              phone: (document.getElementById('phone') as HTMLInputElement)?.value || '',\n              message: (document.getElementById('message') as HTMLTextAreaElement)?.value || '',\n              honeypot: (document.querySelector('input[name=\"honeypot\"]') as HTMLInputElement)?.value || '',\n              csrfToken: csrfToken,\n            };\n\n            // Client-side validation\n            const validationErrors = validateForm(formData);\n            if (validationErrors.length > 0) {\n              showError(validationErrors[0]);\n              return;\n            }\n\n            // Show loading state\n            setLoadingState(true);\n            messageDiv.classList.add('hidden');\n\n            try {\n              const response = await fetch('/api/contact', {\n                method: 'POST',\n                headers: {\n                  'Content-Type': 'application/json',\n                },\n                body: JSON.stringify(formData),\n              });\n\n              // Parse response with proper error handling\n              let data: ApiResponse;\n              try {\n                data = await response.json() as ApiResponse;\n              } catch (parseError) {\n                // Handle JSON parse errors\n                showError(text.errors.network);\n                setLoadingState(false);\n                return;\n              }\n\n              // Handle response based on standardized format\n              if (response.ok && 'success' in data && data.success === true) {\n                showSuccess(handleApiSuccess(data));\n                form.reset();\n                // Fetch new CSRF token after successful submission\n                fetchCsrfToken().then(token => {\n                  csrfToken = token;\n                  if (csrfTokenInput && token) {\n                    csrfTokenInput.value = token;\n                  }\n                });\n              } else if ('success' in data && data.success === false) {\n                showError(handleApiError(data));\n              } else {\n                // Fallback for unexpected response format\n                showError(text.errors.generic);\n              }\n            } catch (error) {\n              // Handle network errors, fetch failures, etc.\n              console.error('Contact form submission error:', error);\n              showError(text.errors.network);\n            } finally {\n              setLoadingState(false);\n            }\n          } catch (error) {\n            // Handle unexpected errors in form submission\n            console.error('Unexpected form error:', error);\n            showError(text.errors.network);\n            setLoadingState(false);\n          }\n        });\n      }\n    } catch (error) {\n      // Silently fail - form will still work via native HTML submission if JS fails\n    }\n  })();\n})();<\/script>"])), maybeRenderHead(), text.heading, text.description, text.available, addAttribute(`tel:${formatPhoneTel(phone)}`, "href"), formatPhoneDisplay(phone), text.formLabels.name, addAttribute(text.placeholders.name, "placeholder"), text.formLabels.email, addAttribute(text.placeholders.email, "placeholder"), text.formLabels.phone, addAttribute(text.placeholders.phone, "placeholder"), text.formLabels.message, addAttribute(text.placeholders.message, "placeholder"), text.submitButton, defineScriptVars({ language, text }));
}, "C:/Users/User A/Documents/GitHub/funeral-home-landing-site/src/components/ContactForm.astro", void 0);

export { $$ContactForm as $, $$OngoingCare as a };
